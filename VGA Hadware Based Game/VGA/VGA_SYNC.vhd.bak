LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

USE WORK.VGA_LIBRERIA.ALL;   --- NOT MY TOP ENTITY


ENTITY VGA_SYNC IS
    PORT ( CLK_25MHZ  , RST: IN STD_LOGIC;            --Clock 25 MHz para hacer uso de una adecuada conexion VGA y un reset  clock.
           H_SYNC, V_SYNC , VIDEO_ON  : OUT STD_LOGIC;
			  HCOUNT , VCOUNT : OUT  STD_LOGIC_VECTOR(9 DOWNTO 0));
			   --contador actual horizontal y vertical , y senal 
			  --para los pulsos de sincroniacion horizontal y vertical ,asi como una senal para dibujar en el area especificada.
    END VGA_SYNC;

ARCHITECTURE BEHAVIORAL OF VGA_SYNC IS

SIGNAL H_COUNT : STD_LOGIC_VECTOR(9 DOWNTO 0):= "0000000000"; --Contador para testbench.
SIGNAL V_COUNT : STD_LOGIC_VECTOR(9 DOWNTO 0):= "0000000000";

BEGIN

HCOUNT<= H_COUNT;
VCOUNT<= V_COUNT;


PROCESS(CLK_25MHz)
BEGIN
IF RISING_EDGE(CLK_25MHz) THEN   --CADA PULSO DEL RELOJ
	
	IF H_COUNT < H_MAX THEN       --INCREMENTA CONTADOR HASTA EL LIMITE HORIZONTAL , DE OTRO MODO LO REINICIA.
	H_COUNT <= H_COUNT + 1;   
	ELSE
	H_COUNT <=  (OTHERS =>'0');
	
		IF V_COUNT < V_MAX THEN     --INCREMENTA CONTADOR HASTA EL LIMITE VERTICAL , DE OTRO MODO LO REINICIA.
		V_COUNT <= V_COUNT + 1;
		ELSE
		V_COUNT <= (OTHERS =>'0');
		END IF;
   END IF;
	
	--SYNC
	IF H_COUNT >= HSYNC_BEGIN AND H_COUNT <= HSYNC_END 	THEN  --EN EL RANGO DEL PULSO DE SYNC DEBE ESTAR EN ESTADO LOW
	H_SYNC <= '0';
	ELSE
	H_SYNC <= '1';
	END IF;
	
	IF V_COUNT >= VSYNC_BEGIN AND V_COUNT <= VSYNC_END THEN
	V_SYNC <= '0';
	ELSE
	V_SYNC <= '1';
	END IF;
	
	IF (H_COUNT > 0 AND H_COUNT <= H_DISPLAY_END)  OR (V_COUNT > 0  AND V_COUNT <= V_DISPLAY_END ) THEN
	VIDEO_ON <='1';
	ELSE
	VIDEO_ON <='0';
	END IF;

END IF;
END PROCESS;
END BEHAVIORAL;